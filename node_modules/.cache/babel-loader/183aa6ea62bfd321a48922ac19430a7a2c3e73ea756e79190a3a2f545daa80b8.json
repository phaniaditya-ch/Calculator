{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { escape } from '../../utils/string.js';\nimport { forEach, join } from '../../utils/array.js';\nimport { toSymbol } from '../../utils/latex.js';\nimport { getPrecedence } from '../operators.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    Node = _ref.Node;\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @param {string} implicit\n   * @private\n   */\n  function needParenthesis(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  var FunctionAssignmentNode = /*#__PURE__*/function (_Node) {\n    _inherits(FunctionAssignmentNode, _Node);\n    var _super = _createSuper(FunctionAssignmentNode);\n    /**\n     * @constructor FunctionAssignmentNode\n     * @extends {Node}\n     * Function assignment\n     *\n     * @param {string} name           Function name\n     * @param {string[] | Array.<{name: string, type: string}>} params\n     *                                Array with function parameter names, or an\n     *                                array with objects containing the name\n     *                                and type of the parameter\n     * @param {Node} expr             The function expression\n     */\n    function FunctionAssignmentNode(name, params, expr) {\n      var _this;\n      _classCallCheck(this, FunctionAssignmentNode);\n      _this = _super.call(this);\n      // validate input\n      if (typeof name !== 'string') {\n        throw new TypeError('String expected for parameter \"name\"');\n      }\n      if (!Array.isArray(params)) {\n        throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n      }\n      if (!isNode(expr)) {\n        throw new TypeError('Node expected for parameter \"expr\"');\n      }\n      if (keywords.has(name)) {\n        throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n      }\n      var paramNames = new Set();\n      var _iterator = _createForOfIteratorHelper(params),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var param = _step.value;\n          var _name = typeof param === 'string' ? param : param.name;\n          if (paramNames.has(_name)) {\n            throw new Error(\"Duplicate parameter name \\\"\".concat(_name, \"\\\"\"));\n          } else {\n            paramNames.add(_name);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      _this.name = name;\n      _this.params = params.map(function (param) {\n        return param && param.name || param;\n      });\n      _this.types = params.map(function (param) {\n        return param && param.type || 'any';\n      });\n      _this.expr = expr;\n      return _this;\n    }\n    _createClass(FunctionAssignmentNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isFunctionAssignmentNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        var childArgNames = Object.create(argNames);\n        forEach(this.params, function (param) {\n          childArgNames[param] = true;\n        });\n\n        // compile the function expression with the child args\n        var evalExpr = this.expr._compile(math, childArgNames);\n        var name = this.name;\n        var params = this.params;\n        var signature = join(this.types, ',');\n        var syntax = name + '(' + join(this.params, ', ') + ')';\n        return function evalFunctionAssignmentNode(scope, args, context) {\n          var signatures = {};\n          signatures[signature] = function () {\n            var childArgs = Object.create(args);\n            for (var i = 0; i < params.length; i++) {\n              childArgs[params[i]] = arguments[i];\n            }\n            return evalExpr(scope, childArgs, context);\n          };\n          var fn = typed(name, signatures);\n          fn.syntax = syntax;\n          scope.set(name, fn);\n          return fn;\n        };\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        callback(this.expr, 'expr', this);\n      }\n\n      /**\n       * Create a new FunctionAssignmentNode whose children are the results of\n       * calling the provided callback function for each child of the original\n       * node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        var expr = this._ifNode(callback(this.expr, 'expr', this));\n        return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n      }\n\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {FunctionAssignmentNode}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n      }\n\n      /**\n       * get string representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var expr = this.expr.toString(options);\n        if (needParenthesis(this, parenthesis, options && options.implicit)) {\n          expr = '(' + expr + ')';\n        }\n        return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        var types = this.types;\n        return {\n          mathjs: name,\n          name: this.name,\n          params: this.params.map(function (param, index) {\n            return {\n              name: param,\n              type: types[index]\n            };\n          }),\n          expr: this.expr\n        };\n      }\n\n      /**\n       * Instantiate an FunctionAssignmentNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     ```\n       *     {\"mathjs\": \"FunctionAssignmentNode\",\n       *      name: ..., params: ..., expr: ...}\n       *     ```\n       *     where mathjs is optional\n       * @returns {FunctionAssignmentNode}\n       */\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\n       * get HTML representation\n       * @param {Object} options\n       * @return {string} str\n       */\n      function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var params = [];\n        for (var i = 0; i < this.params.length; i++) {\n          params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n        }\n        var expr = this.expr.toHTML(options);\n        if (needParenthesis(this, parenthesis, options && options.implicit)) {\n          expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n      }\n\n      /**\n       * get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var expr = this.expr.toTex(options);\n        if (needParenthesis(this, parenthesis, options && options.implicit)) {\n          expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n        }\n        return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right):=' + expr;\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new FunctionAssignmentNode(json.name, json.params, json.expr);\n      }\n    }]);\n    return FunctionAssignmentNode;\n  }(Node);\n  _defineProperty(FunctionAssignmentNode, \"name\", name);\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isNode","keywords","escape","forEach","join","toSymbol","getPrecedence","factory","name","dependencies","createFunctionAssignmentNode","_ref","typed","Node","needParenthesis","node","parenthesis","implicit","precedence","exprPrecedence","expr","FunctionAssignmentNode","_Node","_inherits","_super","_createSuper","params","_this","_classCallCheck","call","TypeError","Array","isArray","has","Error","paramNames","Set","_iterator","_createForOfIteratorHelper","_step","s","n","done","param","value","_name","concat","add","err","e","f","map","types","type","_createClass","key","get","_compile","math","argNames","childArgNames","Object","create","evalExpr","signature","syntax","evalFunctionAssignmentNode","scope","args","context","signatures","childArgs","i","length","arguments","fn","set","callback","_ifNode","slice","clone","_toString","options","toString","toJSON","mathjs","index","toHTML","push","_toTex","toTex","fromJSON","json","isClass"],"sources":["C:/Users/chpha/Desktop/calculator/node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { escape } from '../../utils/string.js';\nimport { forEach, join } from '../../utils/array.js';\nimport { toSymbol } from '../../utils/latex.js';\nimport { getPrecedence } from '../operators.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    Node\n  } = _ref;\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @param {string} implicit\n   * @private\n   */\n  function needParenthesis(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  class FunctionAssignmentNode extends Node {\n    /**\n     * @constructor FunctionAssignmentNode\n     * @extends {Node}\n     * Function assignment\n     *\n     * @param {string} name           Function name\n     * @param {string[] | Array.<{name: string, type: string}>} params\n     *                                Array with function parameter names, or an\n     *                                array with objects containing the name\n     *                                and type of the parameter\n     * @param {Node} expr             The function expression\n     */\n    constructor(name, params, expr) {\n      super();\n      // validate input\n      if (typeof name !== 'string') {\n        throw new TypeError('String expected for parameter \"name\"');\n      }\n      if (!Array.isArray(params)) {\n        throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n      }\n      if (!isNode(expr)) {\n        throw new TypeError('Node expected for parameter \"expr\"');\n      }\n      if (keywords.has(name)) {\n        throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n      }\n      var paramNames = new Set();\n      for (var param of params) {\n        var _name = typeof param === 'string' ? param : param.name;\n        if (paramNames.has(_name)) {\n          throw new Error(\"Duplicate parameter name \\\"\".concat(_name, \"\\\"\"));\n        } else {\n          paramNames.add(_name);\n        }\n      }\n      this.name = name;\n      this.params = params.map(function (param) {\n        return param && param.name || param;\n      });\n      this.types = params.map(function (param) {\n        return param && param.type || 'any';\n      });\n      this.expr = expr;\n    }\n    get type() {\n      return name;\n    }\n    get isFunctionAssignmentNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var childArgNames = Object.create(argNames);\n      forEach(this.params, function (param) {\n        childArgNames[param] = true;\n      });\n\n      // compile the function expression with the child args\n      var evalExpr = this.expr._compile(math, childArgNames);\n      var name = this.name;\n      var params = this.params;\n      var signature = join(this.types, ',');\n      var syntax = name + '(' + join(this.params, ', ') + ')';\n      return function evalFunctionAssignmentNode(scope, args, context) {\n        var signatures = {};\n        signatures[signature] = function () {\n          var childArgs = Object.create(args);\n          for (var i = 0; i < params.length; i++) {\n            childArgs[params[i]] = arguments[i];\n          }\n          return evalExpr(scope, childArgs, context);\n        };\n        var fn = typed(name, signatures);\n        fn.syntax = syntax;\n        scope.set(name, fn);\n        return fn;\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      callback(this.expr, 'expr', this);\n    }\n\n    /**\n     * Create a new FunctionAssignmentNode whose children are the results of\n     * calling the provided callback function for each child of the original\n     * node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      var expr = this._ifNode(callback(this.expr, 'expr', this));\n      return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {FunctionAssignmentNode}\n     */\n    clone() {\n      return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n    }\n\n    /**\n     * get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var expr = this.expr.toString(options);\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\n        expr = '(' + expr + ')';\n      }\n      return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      var types = this.types;\n      return {\n        mathjs: name,\n        name: this.name,\n        params: this.params.map(function (param, index) {\n          return {\n            name: param,\n            type: types[index]\n          };\n        }),\n        expr: this.expr\n      };\n    }\n\n    /**\n     * Instantiate an FunctionAssignmentNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     ```\n     *     {\"mathjs\": \"FunctionAssignmentNode\",\n     *      name: ..., params: ..., expr: ...}\n     *     ```\n     *     where mathjs is optional\n     * @returns {FunctionAssignmentNode}\n     */\n    static fromJSON(json) {\n      return new FunctionAssignmentNode(json.name, json.params, json.expr);\n    }\n\n    /**\n     * get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var params = [];\n      for (var i = 0; i < this.params.length; i++) {\n        params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n      }\n      var expr = this.expr.toHTML(options);\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\n        expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n    }\n\n    /**\n     * get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var expr = this.expr.toTex(options);\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\n        expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n      }\n      return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right):=' + expr;\n    }\n  }\n  _defineProperty(FunctionAssignmentNode, \"name\", name);\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}