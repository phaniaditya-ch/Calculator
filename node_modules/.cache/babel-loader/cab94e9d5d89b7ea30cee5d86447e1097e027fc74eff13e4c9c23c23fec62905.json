{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { setSafeProperty, hasSafeProperty, getSafeProperty } from './customs.js';\nimport { isObject } from './is.js';\n\n/**\n * A map facade on a bare object.\n *\n * The small number of methods needed to implement a scope,\n * forwarding on to the SafeProperty functions. Over time, the codebase\n * will stop using this method, as all objects will be Maps, rather than\n * more security prone objects.\n */\nexport var ObjectWrappingMap = /*#__PURE__*/function () {\n  function ObjectWrappingMap(object) {\n    _classCallCheck(this, ObjectWrappingMap);\n    this.wrappedObject = object;\n  }\n  _createClass(ObjectWrappingMap, [{\n    key: \"keys\",\n    value: function keys() {\n      return Object.keys(this.wrappedObject);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      return getSafeProperty(this.wrappedObject, key);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      setSafeProperty(this.wrappedObject, key, value);\n      return this;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return hasSafeProperty(this.wrappedObject, key);\n    }\n  }]);\n  return ObjectWrappingMap;\n}();\n\n/**\n * Creates an empty map, or whatever your platform's polyfill is.\n *\n * @returns an empty Map or Map like object.\n */\nexport function createEmptyMap() {\n  return new Map();\n}\n\n/**\n * Creates a Map from the given object.\n *\n * @param { Map | { [key: string]: unknown } | undefined } mapOrObject\n * @returns\n */\nexport function createMap(mapOrObject) {\n  if (!mapOrObject) {\n    return createEmptyMap();\n  }\n  if (isMap(mapOrObject)) {\n    return mapOrObject;\n  }\n  if (isObject(mapOrObject)) {\n    return new ObjectWrappingMap(mapOrObject);\n  }\n  throw new Error('createMap can create maps from objects or Maps');\n}\n\n/**\n * Unwraps a map into an object.\n *\n * @param {Map} map\n * @returns { [key: string]: unknown }\n */\nexport function toObject(map) {\n  if (map instanceof ObjectWrappingMap) {\n    return map.wrappedObject;\n  }\n  var object = {};\n  var _iterator = _createForOfIteratorHelper(map.keys()),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      var value = map.get(key);\n      setSafeProperty(object, key, value);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return object;\n}\n\n/**\n * Returns `true` if the passed object appears to be a Map (i.e. duck typing).\n *\n * Methods looked for are `get`, `set`, `keys` and `has`.\n *\n * @param {Map | object} object\n * @returns\n */\nexport function isMap(object) {\n  // We can use the fast instanceof, or a slower duck typing check.\n  // The duck typing method needs to cover enough methods to not be confused with DenseMatrix.\n  if (!object) {\n    return false;\n  }\n  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === 'function' && typeof object.get === 'function' && typeof object.keys === 'function' && typeof object.has === 'function';\n}\n\n/**\n * Copies the contents of key-value pairs from each `objects` in to `map`.\n *\n * Object is `objects` can be a `Map` or object.\n *\n * This is the `Map` analog to `Object.assign`.\n */\nexport function assign(map) {\n  for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n  for (var _i = 0, _objects = objects; _i < _objects.length; _i++) {\n    var args = _objects[_i];\n    if (!args) {\n      continue;\n    }\n    if (isMap(args)) {\n      var _iterator2 = _createForOfIteratorHelper(args.keys()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var key = _step2.value;\n          map.set(key, args.get(key));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else if (isObject(args)) {\n      for (var _i2 = 0, _Object$keys = Object.keys(args); _i2 < _Object$keys.length; _i2++) {\n        var _key2 = _Object$keys[_i2];\n        map.set(_key2, args[_key2]);\n      }\n    }\n  }\n  return map;\n}","map":{"version":3,"names":["setSafeProperty","hasSafeProperty","getSafeProperty","isObject","ObjectWrappingMap","object","_classCallCheck","wrappedObject","_createClass","key","value","keys","Object","get","set","has","createEmptyMap","Map","createMap","mapOrObject","isMap","Error","toObject","map","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","assign","_len","arguments","length","objects","Array","_key","_i","_objects","args","_iterator2","_step2","_i2","_Object$keys","_key2"],"sources":["C:/Users/chpha/Desktop/calculator/node_modules/mathjs/lib/esm/utils/map.js"],"sourcesContent":["import { setSafeProperty, hasSafeProperty, getSafeProperty } from './customs.js';\nimport { isObject } from './is.js';\n\n/**\n * A map facade on a bare object.\n *\n * The small number of methods needed to implement a scope,\n * forwarding on to the SafeProperty functions. Over time, the codebase\n * will stop using this method, as all objects will be Maps, rather than\n * more security prone objects.\n */\nexport class ObjectWrappingMap {\n  constructor(object) {\n    this.wrappedObject = object;\n  }\n  keys() {\n    return Object.keys(this.wrappedObject);\n  }\n  get(key) {\n    return getSafeProperty(this.wrappedObject, key);\n  }\n  set(key, value) {\n    setSafeProperty(this.wrappedObject, key, value);\n    return this;\n  }\n  has(key) {\n    return hasSafeProperty(this.wrappedObject, key);\n  }\n}\n\n/**\n * Creates an empty map, or whatever your platform's polyfill is.\n *\n * @returns an empty Map or Map like object.\n */\nexport function createEmptyMap() {\n  return new Map();\n}\n\n/**\n * Creates a Map from the given object.\n *\n * @param { Map | { [key: string]: unknown } | undefined } mapOrObject\n * @returns\n */\nexport function createMap(mapOrObject) {\n  if (!mapOrObject) {\n    return createEmptyMap();\n  }\n  if (isMap(mapOrObject)) {\n    return mapOrObject;\n  }\n  if (isObject(mapOrObject)) {\n    return new ObjectWrappingMap(mapOrObject);\n  }\n  throw new Error('createMap can create maps from objects or Maps');\n}\n\n/**\n * Unwraps a map into an object.\n *\n * @param {Map} map\n * @returns { [key: string]: unknown }\n */\nexport function toObject(map) {\n  if (map instanceof ObjectWrappingMap) {\n    return map.wrappedObject;\n  }\n  var object = {};\n  for (var key of map.keys()) {\n    var value = map.get(key);\n    setSafeProperty(object, key, value);\n  }\n  return object;\n}\n\n/**\n * Returns `true` if the passed object appears to be a Map (i.e. duck typing).\n *\n * Methods looked for are `get`, `set`, `keys` and `has`.\n *\n * @param {Map | object} object\n * @returns\n */\nexport function isMap(object) {\n  // We can use the fast instanceof, or a slower duck typing check.\n  // The duck typing method needs to cover enough methods to not be confused with DenseMatrix.\n  if (!object) {\n    return false;\n  }\n  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === 'function' && typeof object.get === 'function' && typeof object.keys === 'function' && typeof object.has === 'function';\n}\n\n/**\n * Copies the contents of key-value pairs from each `objects` in to `map`.\n *\n * Object is `objects` can be a `Map` or object.\n *\n * This is the `Map` analog to `Object.assign`.\n */\nexport function assign(map) {\n  for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n  for (var args of objects) {\n    if (!args) {\n      continue;\n    }\n    if (isMap(args)) {\n      for (var key of args.keys()) {\n        map.set(key, args.get(key));\n      }\n    } else if (isObject(args)) {\n      for (var _key2 of Object.keys(args)) {\n        map.set(_key2, args[_key2]);\n      }\n    }\n  }\n  return map;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}