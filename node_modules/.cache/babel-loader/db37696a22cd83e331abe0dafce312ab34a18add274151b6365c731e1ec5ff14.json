{"ast":null,"code":"import _classCallCheck from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _toConsumableArray from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { deepStrictEqual } from '../../utils/object.js';\nimport { factory } from '../../utils/factory.js';\nimport { createMap } from '../../utils/map.js';\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nexport var createNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var mathWithTransform = _ref.mathWithTransform;\n  /**\n   * Validate the symbol names of a scope.\n   * Throws an error when the scope contains an illegal symbol.\n   * @param {Object} scope\n   */\n  function _validateScope(scope) {\n    for (var _i = 0, _arr = _toConsumableArray(keywords); _i < _arr.length; _i++) {\n      var symbol = _arr[_i];\n      if (scope.has(symbol)) {\n        throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n      }\n    }\n  }\n  var Node = /*#__PURE__*/function () {\n    function Node() {\n      _classCallCheck(this, Node);\n    }\n    _createClass(Node, [{\n      key: \"type\",\n      get: function get() {\n        return 'Node';\n      }\n    }, {\n      key: \"isNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Evaluate the node\n       * @param {Object} [scope]  Scope to read/write variables\n       * @return {*}              Returns the result\n       */\n    }, {\n      key: \"evaluate\",\n      value: function evaluate(scope) {\n        return this.compile().evaluate(scope);\n      }\n\n      /**\n       * Compile the node into an optimized, evauatable JavaScript function\n       * @return {{evaluate: function([Object])}} object\n       *                Returns an object with a function 'evaluate',\n       *                which can be invoked as expr.evaluate([scope: Object]),\n       *                where scope is an optional object with\n       *                variables.\n       */\n    }, {\n      key: \"compile\",\n      value: function compile() {\n        var expr = this._compile(mathWithTransform, {});\n        var args = {};\n        var context = null;\n        function evaluate(scope) {\n          var s = createMap(scope);\n          _validateScope(s);\n          return expr(s, args, context);\n        }\n        return {\n          evaluate: evaluate\n        };\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        throw new Error('Method _compile must be implemented by type ' + this.type);\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        // must be implemented by each of the Node implementations\n        throw new Error('Cannot run forEach on a Node interface');\n      }\n\n      /**\n       * Create a new Node whose children are the results of calling the\n       * provided callback function for each child of the original node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {OperatorNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        // must be implemented by each of the Node implementations\n        throw new Error('Cannot run map on a Node interface');\n      }\n\n      /**\n       * Validate whether an object is a Node, for use with map\n       * @param {Node} node\n       * @returns {Node} Returns the input if it's a node, else throws an Error\n       * @protected\n       */\n    }, {\n      key: \"_ifNode\",\n      value: function _ifNode(node) {\n        if (!isNode(node)) {\n          throw new TypeError('Callback function must return a Node');\n        }\n        return node;\n      }\n\n      /**\n       * Recursively traverse all nodes in a node tree. Executes given callback for\n       * this node and each of its child nodes.\n       * @param {function(node: Node, path: string, parent: Node)} callback\n       *          A callback called for every node in the node tree.\n       */\n    }, {\n      key: \"traverse\",\n      value: function traverse(callback) {\n        // execute callback for itself\n        // eslint-disable-next-line\n        callback(this, null, null);\n\n        // recursively traverse over all children of a node\n        function _traverse(node, callback) {\n          node.forEach(function (child, path, parent) {\n            callback(child, path, parent);\n            _traverse(child, callback);\n          });\n        }\n        _traverse(this, callback);\n      }\n\n      /**\n       * Recursively transform a node tree via a transform function.\n       *\n       * For example, to replace all nodes of type SymbolNode having name 'x' with\n       * a ConstantNode with value 2:\n       *\n       *     const res = Node.transform(function (node, path, parent) {\n       *       if (node && node.isSymbolNode) && (node.name === 'x')) {\n       *         return new ConstantNode(2)\n       *       }\n       *       else {\n       *         return node\n       *       }\n       *     })\n       *\n       * @param {function(node: Node, path: string, parent: Node) : Node} callback\n       *          A mapping function accepting a node, and returning\n       *          a replacement for the node or the original node. The \"signature\"\n       *          of the callback must be:\n       *          callback(node: Node, index: string, parent: Node) : Node\n       * @return {Node} Returns the original node or its replacement\n       */\n    }, {\n      key: \"transform\",\n      value: function transform(callback) {\n        function _transform(child, path, parent) {\n          var replacement = callback(child, path, parent);\n          if (replacement !== child) {\n            // stop iterating when the node is replaced\n            return replacement;\n          }\n          return child.map(_transform);\n        }\n        return _transform(this, null, null);\n      }\n\n      /**\n       * Find any node in the node tree matching given filter function. For\n       * example, to find all nodes of type SymbolNode having name 'x':\n       *\n       *     const results = Node.filter(function (node) {\n       *       return (node && node.isSymbolNode) && (node.name === 'x')\n       *     })\n       *\n       * @param {function(node: Node, path: string, parent: Node) : Node} callback\n       *            A test function returning true when a node matches, and false\n       *            otherwise. Function signature:\n       *            callback(node: Node, index: string, parent: Node) : boolean\n       * @return {Node[]} nodes\n       *            An array with nodes matching given filter criteria\n       */\n    }, {\n      key: \"filter\",\n      value: function filter(callback) {\n        var nodes = [];\n        this.traverse(function (node, path, parent) {\n          if (callback(node, path, parent)) {\n            nodes.push(node);\n          }\n        });\n        return nodes;\n      }\n\n      /**\n       * Create a shallow clone of this node\n       * @return {Node}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        // must be implemented by each of the Node implementations\n        throw new Error('Cannot clone a Node interface');\n      }\n\n      /**\n       * Create a deep clone of this node\n       * @return {Node}\n       */\n    }, {\n      key: \"cloneDeep\",\n      value: function cloneDeep() {\n        return this.map(function (node) {\n          return node.cloneDeep();\n        });\n      }\n\n      /**\n       * Deep compare this node with another node.\n       * @param {Node} other\n       * @return {boolean} Returns true when both nodes are of the same type and\n       *                   contain the same values (as do their childs)\n       */\n    }, {\n      key: \"equals\",\n      value: function equals(other) {\n        return other ? this.type === other.type && deepStrictEqual(this, other) : false;\n      }\n\n      /**\n       * Get string representation. (wrapper function)\n       *\n       * This function can get an object of the following form:\n       * {\n       *    handler: //This can be a callback function of the form\n       *             // \"function callback(node, options)\"or\n       *             // a map that maps function names (used in FunctionNodes)\n       *             // to callbacks\n       *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n       * }\n       *\n       * @param {Object} [options]\n       * @return {string}\n       */\n    }, {\n      key: \"toString\",\n      value: function toString(options) {\n        var customString = this._getCustomString(options);\n        if (typeof customString !== 'undefined') {\n          return customString;\n        }\n        return this._toString(options);\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * Both .toJSON() and the static .fromJSON(json) should be implemented by all\n       * implementations of Node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n      }\n\n      /**\n       * Get HTML representation. (wrapper function)\n       *\n       * This function can get an object of the following form:\n       * {\n       *    handler: //This can be a callback function of the form\n       *             // \"function callback(node, options)\" or\n       *             // a map that maps function names (used in FunctionNodes)\n       *             // to callbacks\n       *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n       * }\n       *\n       * @param {Object} [options]\n       * @return {string}\n       */\n    }, {\n      key: \"toHTML\",\n      value: function toHTML(options) {\n        var customString = this._getCustomString(options);\n        if (typeof customString !== 'undefined') {\n          return customString;\n        }\n        return this.toHTML(options);\n      }\n\n      /**\n       * Internal function to generate the string output.\n       * This has to be implemented by every Node\n       *\n       * @throws {Error}\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString() {\n        // must be implemented by each of the Node implementations\n        throw new Error('_toString not implemented for ' + this.type);\n      }\n\n      /**\n       * Get LaTeX representation. (wrapper function)\n       *\n       * This function can get an object of the following form:\n       * {\n       *    handler: //This can be a callback function of the form\n       *             // \"function callback(node, options)\"or\n       *             // a map that maps function names (used in FunctionNodes)\n       *             // to callbacks\n       *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n       * }\n       *\n       * @param {Object} [options]\n       * @return {string}\n       */\n    }, {\n      key: \"toTex\",\n      value: function toTex(options) {\n        var customString = this._getCustomString(options);\n        if (typeof customString !== 'undefined') {\n          return customString;\n        }\n        return this._toTex(options);\n      }\n\n      /**\n       * Internal function to generate the LaTeX output.\n       * This has to be implemented by every Node\n       *\n       * @param {Object} [options]\n       * @throws {Error}\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        // must be implemented by each of the Node implementations\n        throw new Error('_toTex not implemented for ' + this.type);\n      }\n\n      /**\n       * Helper used by `to...` functions.\n       */\n    }, {\n      key: \"_getCustomString\",\n      value: function _getCustomString(options) {\n        if (options && typeof options === 'object') {\n          switch (typeof options.handler) {\n            case 'object':\n            case 'undefined':\n              return;\n            case 'function':\n              return options.handler(this, options);\n            default:\n              throw new TypeError('Object or function expected as callback');\n          }\n        }\n      }\n\n      /**\n       * Get identifier.\n       * @return {string}\n       */\n    }, {\n      key: \"getIdentifier\",\n      value: function getIdentifier() {\n        return this.type;\n      }\n\n      /**\n       * Get the content of the current Node.\n       * @return {Node} node\n       **/\n    }, {\n      key: \"getContent\",\n      value: function getContent() {\n        return this;\n      }\n    }]);\n    return Node;\n  }();\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isNode","keywords","deepStrictEqual","factory","createMap","name","dependencies","createNode","_ref","mathWithTransform","_validateScope","scope","_i","_arr","_toConsumableArray","length","symbol","has","Error","Node","_classCallCheck","_createClass","key","get","value","evaluate","compile","expr","_compile","args","context","s","math","argNames","type","forEach","callback","map","_ifNode","node","TypeError","traverse","_traverse","child","path","parent","transform","_transform","replacement","filter","nodes","push","clone","cloneDeep","equals","other","toString","options","customString","_getCustomString","_toString","toJSON","toHTML","toTex","_toTex","handler","getIdentifier","getContent","isClass"],"sources":["C:/Users/chpha/Desktop/calculator/node_modules/mathjs/lib/esm/expression/node/Node.js"],"sourcesContent":["import { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { deepStrictEqual } from '../../utils/object.js';\nimport { factory } from '../../utils/factory.js';\nimport { createMap } from '../../utils/map.js';\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nexport var createNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    mathWithTransform\n  } = _ref;\n  /**\n   * Validate the symbol names of a scope.\n   * Throws an error when the scope contains an illegal symbol.\n   * @param {Object} scope\n   */\n  function _validateScope(scope) {\n    for (var symbol of [...keywords]) {\n      if (scope.has(symbol)) {\n        throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n      }\n    }\n  }\n  class Node {\n    get type() {\n      return 'Node';\n    }\n    get isNode() {\n      return true;\n    }\n\n    /**\n     * Evaluate the node\n     * @param {Object} [scope]  Scope to read/write variables\n     * @return {*}              Returns the result\n     */\n    evaluate(scope) {\n      return this.compile().evaluate(scope);\n    }\n\n    /**\n     * Compile the node into an optimized, evauatable JavaScript function\n     * @return {{evaluate: function([Object])}} object\n     *                Returns an object with a function 'evaluate',\n     *                which can be invoked as expr.evaluate([scope: Object]),\n     *                where scope is an optional object with\n     *                variables.\n     */\n    compile() {\n      var expr = this._compile(mathWithTransform, {});\n      var args = {};\n      var context = null;\n      function evaluate(scope) {\n        var s = createMap(scope);\n        _validateScope(s);\n        return expr(s, args, context);\n      }\n      return {\n        evaluate\n      };\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      throw new Error('Method _compile must be implemented by type ' + this.type);\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      // must be implemented by each of the Node implementations\n      throw new Error('Cannot run forEach on a Node interface');\n    }\n\n    /**\n     * Create a new Node whose children are the results of calling the\n     * provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {OperatorNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      // must be implemented by each of the Node implementations\n      throw new Error('Cannot run map on a Node interface');\n    }\n\n    /**\n     * Validate whether an object is a Node, for use with map\n     * @param {Node} node\n     * @returns {Node} Returns the input if it's a node, else throws an Error\n     * @protected\n     */\n    _ifNode(node) {\n      if (!isNode(node)) {\n        throw new TypeError('Callback function must return a Node');\n      }\n      return node;\n    }\n\n    /**\n     * Recursively traverse all nodes in a node tree. Executes given callback for\n     * this node and each of its child nodes.\n     * @param {function(node: Node, path: string, parent: Node)} callback\n     *          A callback called for every node in the node tree.\n     */\n    traverse(callback) {\n      // execute callback for itself\n      // eslint-disable-next-line\n      callback(this, null, null);\n\n      // recursively traverse over all children of a node\n      function _traverse(node, callback) {\n        node.forEach(function (child, path, parent) {\n          callback(child, path, parent);\n          _traverse(child, callback);\n        });\n      }\n      _traverse(this, callback);\n    }\n\n    /**\n     * Recursively transform a node tree via a transform function.\n     *\n     * For example, to replace all nodes of type SymbolNode having name 'x' with\n     * a ConstantNode with value 2:\n     *\n     *     const res = Node.transform(function (node, path, parent) {\n     *       if (node && node.isSymbolNode) && (node.name === 'x')) {\n     *         return new ConstantNode(2)\n     *       }\n     *       else {\n     *         return node\n     *       }\n     *     })\n     *\n     * @param {function(node: Node, path: string, parent: Node) : Node} callback\n     *          A mapping function accepting a node, and returning\n     *          a replacement for the node or the original node. The \"signature\"\n     *          of the callback must be:\n     *          callback(node: Node, index: string, parent: Node) : Node\n     * @return {Node} Returns the original node or its replacement\n     */\n    transform(callback) {\n      function _transform(child, path, parent) {\n        var replacement = callback(child, path, parent);\n        if (replacement !== child) {\n          // stop iterating when the node is replaced\n          return replacement;\n        }\n        return child.map(_transform);\n      }\n      return _transform(this, null, null);\n    }\n\n    /**\n     * Find any node in the node tree matching given filter function. For\n     * example, to find all nodes of type SymbolNode having name 'x':\n     *\n     *     const results = Node.filter(function (node) {\n     *       return (node && node.isSymbolNode) && (node.name === 'x')\n     *     })\n     *\n     * @param {function(node: Node, path: string, parent: Node) : Node} callback\n     *            A test function returning true when a node matches, and false\n     *            otherwise. Function signature:\n     *            callback(node: Node, index: string, parent: Node) : boolean\n     * @return {Node[]} nodes\n     *            An array with nodes matching given filter criteria\n     */\n    filter(callback) {\n      var nodes = [];\n      this.traverse(function (node, path, parent) {\n        if (callback(node, path, parent)) {\n          nodes.push(node);\n        }\n      });\n      return nodes;\n    }\n\n    /**\n     * Create a shallow clone of this node\n     * @return {Node}\n     */\n    clone() {\n      // must be implemented by each of the Node implementations\n      throw new Error('Cannot clone a Node interface');\n    }\n\n    /**\n     * Create a deep clone of this node\n     * @return {Node}\n     */\n    cloneDeep() {\n      return this.map(function (node) {\n        return node.cloneDeep();\n      });\n    }\n\n    /**\n     * Deep compare this node with another node.\n     * @param {Node} other\n     * @return {boolean} Returns true when both nodes are of the same type and\n     *                   contain the same values (as do their childs)\n     */\n    equals(other) {\n      return other ? this.type === other.type && deepStrictEqual(this, other) : false;\n    }\n\n    /**\n     * Get string representation. (wrapper function)\n     *\n     * This function can get an object of the following form:\n     * {\n     *    handler: //This can be a callback function of the form\n     *             // \"function callback(node, options)\"or\n     *             // a map that maps function names (used in FunctionNodes)\n     *             // to callbacks\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n     * }\n     *\n     * @param {Object} [options]\n     * @return {string}\n     */\n    toString(options) {\n      var customString = this._getCustomString(options);\n      if (typeof customString !== 'undefined') {\n        return customString;\n      }\n      return this._toString(options);\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * Both .toJSON() and the static .fromJSON(json) should be implemented by all\n     * implementations of Node\n     * @returns {Object}\n     */\n    toJSON() {\n      throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n    }\n\n    /**\n     * Get HTML representation. (wrapper function)\n     *\n     * This function can get an object of the following form:\n     * {\n     *    handler: //This can be a callback function of the form\n     *             // \"function callback(node, options)\" or\n     *             // a map that maps function names (used in FunctionNodes)\n     *             // to callbacks\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n     * }\n     *\n     * @param {Object} [options]\n     * @return {string}\n     */\n    toHTML(options) {\n      var customString = this._getCustomString(options);\n      if (typeof customString !== 'undefined') {\n        return customString;\n      }\n      return this.toHTML(options);\n    }\n\n    /**\n     * Internal function to generate the string output.\n     * This has to be implemented by every Node\n     *\n     * @throws {Error}\n     */\n    _toString() {\n      // must be implemented by each of the Node implementations\n      throw new Error('_toString not implemented for ' + this.type);\n    }\n\n    /**\n     * Get LaTeX representation. (wrapper function)\n     *\n     * This function can get an object of the following form:\n     * {\n     *    handler: //This can be a callback function of the form\n     *             // \"function callback(node, options)\"or\n     *             // a map that maps function names (used in FunctionNodes)\n     *             // to callbacks\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n     * }\n     *\n     * @param {Object} [options]\n     * @return {string}\n     */\n    toTex(options) {\n      var customString = this._getCustomString(options);\n      if (typeof customString !== 'undefined') {\n        return customString;\n      }\n      return this._toTex(options);\n    }\n\n    /**\n     * Internal function to generate the LaTeX output.\n     * This has to be implemented by every Node\n     *\n     * @param {Object} [options]\n     * @throws {Error}\n     */\n    _toTex(options) {\n      // must be implemented by each of the Node implementations\n      throw new Error('_toTex not implemented for ' + this.type);\n    }\n\n    /**\n     * Helper used by `to...` functions.\n     */\n    _getCustomString(options) {\n      if (options && typeof options === 'object') {\n        switch (typeof options.handler) {\n          case 'object':\n          case 'undefined':\n            return;\n          case 'function':\n            return options.handler(this, options);\n          default:\n            throw new TypeError('Object or function expected as callback');\n        }\n      }\n    }\n\n    /**\n     * Get identifier.\n     * @return {string}\n     */\n    getIdentifier() {\n      return this.type;\n    }\n\n    /**\n     * Get the content of the current Node.\n     * @return {Node} node\n     **/\n    getContent() {\n      return this;\n    }\n  }\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":";;;AAAA,SAASA,MAAM,QAAQ,mBAAmB;AAC1C,SAASC,QAAQ,QAAQ,gBAAgB;AACzC,SAASC,eAAe,QAAQ,uBAAuB;AACvD,SAASC,OAAO,QAAQ,wBAAwB;AAChD,SAASC,SAAS,QAAQ,oBAAoB;AAC9C,IAAIC,IAAI,GAAG,MAAM;AACjB,IAAIC,YAAY,GAAG,CAAC,mBAAmB,CAAC;AACxC,OAAO,IAAIC,UAAU,GAAG,eAAeJ,OAAO,CAACE,IAAI,EAAEC,YAAY,EAAE,UAAAE,IAAI,EAAI;EACzE,IACEC,iBAAiB,GACfD,IAAI,CADNC,iBAAiB;EAEnB;AACF;AACA;AACA;AACA;EACE,SAASC,cAAcA,CAACC,KAAK,EAAE;IAC7B,SAAAC,EAAA,MAAAC,IAAA,GAAAC,kBAAA,CAAuBb,QAAQ,GAAAW,EAAA,GAAAC,IAAA,CAAAE,MAAA,EAAAH,EAAA,IAAG;MAA7B,IAAII,MAAM,GAAAH,IAAA,CAAAD,EAAA;MACb,IAAID,KAAK,CAACM,GAAG,CAACD,MAAM,CAAC,EAAE;QACrB,MAAM,IAAIE,KAAK,CAAC,qCAAqC,GAAGF,MAAM,GAAG,yBAAyB,CAAC;MAC7F;IACF;EACF;EAAC,IACKG,IAAI;IAAA,SAAAA,KAAA;MAAAC,eAAA,OAAAD,IAAA;IAAA;IAAAE,YAAA,CAAAF,IAAA;MAAAG,GAAA;MAAAC,GAAA,EACR,SAAAA,IAAA,EAAW;QACT,OAAO,MAAM;MACf;IAAC;MAAAD,GAAA;MAAAC,GAAA,EACD,SAAAA,IAAA,EAAa;QACX,OAAO,IAAI;MACb;;MAEA;AACJ;AACA;AACA;AACA;IAJI;MAAAD,GAAA;MAAAE,KAAA,EAKA,SAAAC,SAASd,KAAK,EAAE;QACd,OAAO,IAAI,CAACe,OAAO,EAAE,CAACD,QAAQ,CAACd,KAAK,CAAC;MACvC;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IAPI;MAAAW,GAAA;MAAAE,KAAA,EAQA,SAAAE,QAAA,EAAU;QACR,IAAIC,IAAI,GAAG,IAAI,CAACC,QAAQ,CAACnB,iBAAiB,EAAE,CAAC,CAAC,CAAC;QAC/C,IAAIoB,IAAI,GAAG,CAAC,CAAC;QACb,IAAIC,OAAO,GAAG,IAAI;QAClB,SAASL,QAAQA,CAACd,KAAK,EAAE;UACvB,IAAIoB,CAAC,GAAG3B,SAAS,CAACO,KAAK,CAAC;UACxBD,cAAc,CAACqB,CAAC,CAAC;UACjB,OAAOJ,IAAI,CAACI,CAAC,EAAEF,IAAI,EAAEC,OAAO,CAAC;QAC/B;QACA,OAAO;UACLL,QAAQ,EAARA;QACF,CAAC;MACH;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAZI;MAAAH,GAAA;MAAAE,KAAA,EAaA,SAAAI,SAASI,IAAI,EAAEC,QAAQ,EAAE;QACvB,MAAM,IAAIf,KAAK,CAAC,8CAA8C,GAAG,IAAI,CAACgB,IAAI,CAAC;MAC7E;;MAEA;AACJ;AACA;AACA;IAHI;MAAAZ,GAAA;MAAAE,KAAA,EAIA,SAAAW,QAAQC,QAAQ,EAAE;QAChB;QACA,MAAM,IAAIlB,KAAK,CAAC,wCAAwC,CAAC;MAC3D;;MAEA;AACJ;AACA;AACA;AACA;AACA;IALI;MAAAI,GAAA;MAAAE,KAAA,EAMA,SAAAa,IAAID,QAAQ,EAAE;QACZ;QACA,MAAM,IAAIlB,KAAK,CAAC,oCAAoC,CAAC;MACvD;;MAEA;AACJ;AACA;AACA;AACA;AACA;IALI;MAAAI,GAAA;MAAAE,KAAA,EAMA,SAAAc,QAAQC,IAAI,EAAE;QACZ,IAAI,CAACvC,MAAM,CAACuC,IAAI,CAAC,EAAE;UACjB,MAAM,IAAIC,SAAS,CAAC,sCAAsC,CAAC;QAC7D;QACA,OAAOD,IAAI;MACb;;MAEA;AACJ;AACA;AACA;AACA;AACA;IALI;MAAAjB,GAAA;MAAAE,KAAA,EAMA,SAAAiB,SAASL,QAAQ,EAAE;QACjB;QACA;QACAA,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;;QAE1B;QACA,SAASM,SAASA,CAACH,IAAI,EAAEH,QAAQ,EAAE;UACjCG,IAAI,CAACJ,OAAO,CAAC,UAAUQ,KAAK,EAAEC,IAAI,EAAEC,MAAM,EAAE;YAC1CT,QAAQ,CAACO,KAAK,EAAEC,IAAI,EAAEC,MAAM,CAAC;YAC7BH,SAAS,CAACC,KAAK,EAAEP,QAAQ,CAAC;UAC5B,CAAC,CAAC;QACJ;QACAM,SAAS,CAAC,IAAI,EAAEN,QAAQ,CAAC;MAC3B;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IArBI;MAAAd,GAAA;MAAAE,KAAA,EAsBA,SAAAsB,UAAUV,QAAQ,EAAE;QAClB,SAASW,UAAUA,CAACJ,KAAK,EAAEC,IAAI,EAAEC,MAAM,EAAE;UACvC,IAAIG,WAAW,GAAGZ,QAAQ,CAACO,KAAK,EAAEC,IAAI,EAAEC,MAAM,CAAC;UAC/C,IAAIG,WAAW,KAAKL,KAAK,EAAE;YACzB;YACA,OAAOK,WAAW;UACpB;UACA,OAAOL,KAAK,CAACN,GAAG,CAACU,UAAU,CAAC;QAC9B;QACA,OAAOA,UAAU,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;MACrC;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAdI;MAAAzB,GAAA;MAAAE,KAAA,EAeA,SAAAyB,OAAOb,QAAQ,EAAE;QACf,IAAIc,KAAK,GAAG,EAAE;QACd,IAAI,CAACT,QAAQ,CAAC,UAAUF,IAAI,EAAEK,IAAI,EAAEC,MAAM,EAAE;UAC1C,IAAIT,QAAQ,CAACG,IAAI,EAAEK,IAAI,EAAEC,MAAM,CAAC,EAAE;YAChCK,KAAK,CAACC,IAAI,CAACZ,IAAI,CAAC;UAClB;QACF,CAAC,CAAC;QACF,OAAOW,KAAK;MACd;;MAEA;AACJ;AACA;AACA;IAHI;MAAA5B,GAAA;MAAAE,KAAA,EAIA,SAAA4B,MAAA,EAAQ;QACN;QACA,MAAM,IAAIlC,KAAK,CAAC,+BAA+B,CAAC;MAClD;;MAEA;AACJ;AACA;AACA;IAHI;MAAAI,GAAA;MAAAE,KAAA,EAIA,SAAA6B,UAAA,EAAY;QACV,OAAO,IAAI,CAAChB,GAAG,CAAC,UAAUE,IAAI,EAAE;UAC9B,OAAOA,IAAI,CAACc,SAAS,EAAE;QACzB,CAAC,CAAC;MACJ;;MAEA;AACJ;AACA;AACA;AACA;AACA;IALI;MAAA/B,GAAA;MAAAE,KAAA,EAMA,SAAA8B,OAAOC,KAAK,EAAE;QACZ,OAAOA,KAAK,GAAG,IAAI,CAACrB,IAAI,KAAKqB,KAAK,CAACrB,IAAI,IAAIhC,eAAe,CAAC,IAAI,EAAEqD,KAAK,CAAC,GAAG,KAAK;MACjF;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAdI;MAAAjC,GAAA;MAAAE,KAAA,EAeA,SAAAgC,SAASC,OAAO,EAAE;QAChB,IAAIC,YAAY,GAAG,IAAI,CAACC,gBAAgB,CAACF,OAAO,CAAC;QACjD,IAAI,OAAOC,YAAY,KAAK,WAAW,EAAE;UACvC,OAAOA,YAAY;QACrB;QACA,OAAO,IAAI,CAACE,SAAS,CAACH,OAAO,CAAC;MAChC;;MAEA;AACJ;AACA;AACA;AACA;AACA;IALI;MAAAnC,GAAA;MAAAE,KAAA,EAMA,SAAAqC,OAAA,EAAS;QACP,MAAM,IAAI3C,KAAK,CAAC,qDAAqD,GAAG,IAAI,CAACgB,IAAI,CAAC;MACpF;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAdI;MAAAZ,GAAA;MAAAE,KAAA,EAeA,SAAAsC,OAAOL,OAAO,EAAE;QACd,IAAIC,YAAY,GAAG,IAAI,CAACC,gBAAgB,CAACF,OAAO,CAAC;QACjD,IAAI,OAAOC,YAAY,KAAK,WAAW,EAAE;UACvC,OAAOA,YAAY;QACrB;QACA,OAAO,IAAI,CAACI,MAAM,CAACL,OAAO,CAAC;MAC7B;;MAEA;AACJ;AACA;AACA;AACA;AACA;IALI;MAAAnC,GAAA;MAAAE,KAAA,EAMA,SAAAoC,UAAA,EAAY;QACV;QACA,MAAM,IAAI1C,KAAK,CAAC,gCAAgC,GAAG,IAAI,CAACgB,IAAI,CAAC;MAC/D;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAdI;MAAAZ,GAAA;MAAAE,KAAA,EAeA,SAAAuC,MAAMN,OAAO,EAAE;QACb,IAAIC,YAAY,GAAG,IAAI,CAACC,gBAAgB,CAACF,OAAO,CAAC;QACjD,IAAI,OAAOC,YAAY,KAAK,WAAW,EAAE;UACvC,OAAOA,YAAY;QACrB;QACA,OAAO,IAAI,CAACM,MAAM,CAACP,OAAO,CAAC;MAC7B;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IANI;MAAAnC,GAAA;MAAAE,KAAA,EAOA,SAAAwC,OAAOP,OAAO,EAAE;QACd;QACA,MAAM,IAAIvC,KAAK,CAAC,6BAA6B,GAAG,IAAI,CAACgB,IAAI,CAAC;MAC5D;;MAEA;AACJ;AACA;IAFI;MAAAZ,GAAA;MAAAE,KAAA,EAGA,SAAAmC,iBAAiBF,OAAO,EAAE;QACxB,IAAIA,OAAO,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;UAC1C,QAAQ,OAAOA,OAAO,CAACQ,OAAO;YAC5B,KAAK,QAAQ;YACb,KAAK,WAAW;cACd;YACF,KAAK,UAAU;cACb,OAAOR,OAAO,CAACQ,OAAO,CAAC,IAAI,EAAER,OAAO,CAAC;YACvC;cACE,MAAM,IAAIjB,SAAS,CAAC,yCAAyC,CAAC;UAAC;QAErE;MACF;;MAEA;AACJ;AACA;AACA;IAHI;MAAAlB,GAAA;MAAAE,KAAA,EAIA,SAAA0C,cAAA,EAAgB;QACd,OAAO,IAAI,CAAChC,IAAI;MAClB;;MAEA;AACJ;AACA;AACA;IAHI;MAAAZ,GAAA;MAAAE,KAAA,EAIA,SAAA2C,WAAA,EAAa;QACX,OAAO,IAAI;MACb;IAAC;IAAA,OAAAhD,IAAA;EAAA;EAEH,OAAOA,IAAI;AACb,CAAC,EAAE;EACDiD,OAAO,EAAE,IAAI;EACbpE,MAAM,EAAE;AACV,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}