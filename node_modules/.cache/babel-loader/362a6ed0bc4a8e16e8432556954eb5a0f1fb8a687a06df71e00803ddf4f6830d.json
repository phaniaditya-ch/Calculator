{"ast":null,"code":"import { isMatrix } from '../../utils/is.js';\nimport { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { format } from '../../utils/string.js';\nimport { clone } from '../../utils/object.js';\nvar name = 'pinv';\nvar dependencies = ['typed', 'matrix', 'inv', 'deepEqual', 'equal', 'dotDivide', 'dot', 'ctranspose', 'divideScalar', 'multiply', 'add', 'Complex'];\nexport var createPinv = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    matrix = _ref.matrix,\n    inv = _ref.inv,\n    deepEqual = _ref.deepEqual,\n    equal = _ref.equal,\n    dotDivide = _ref.dotDivide,\n    dot = _ref.dot,\n    ctranspose = _ref.ctranspose,\n    divideScalar = _ref.divideScalar,\n    multiply = _ref.multiply,\n    add = _ref.add,\n    Complex = _ref.Complex;\n  /**\n   * Calculate the Moore–Penrose inverse of a matrix.\n   *\n   * Syntax:\n   *\n   *     math.pinv(x)\n   *\n   * Examples:\n   *\n   *     math.pinv([[1, 2], [3, 4]])          // returns [[-2, 1], [1.5, -0.5]]\n   *     math.pinv([[1, 0], [0, 1], [0, 1]])  // returns [[1, 0, 0], [0, 0.5, 0.5]]\n   *     math.pinv(4)                         // returns 0.25\n   *\n   * See also:\n   *\n   *     inv\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(x) {\n      var size = isMatrix(x) ? x.size() : arraySize(x);\n      switch (size.length) {\n        case 1:\n          // vector\n          if (_isZeros(x)) return ctranspose(x); // null vector\n          if (size[0] === 1) {\n            return inv(x); // invertible matrix\n          } else {\n            return dotDivide(ctranspose(x), dot(x, x));\n          }\n        case 2:\n          // two dimensional array\n          {\n            if (_isZeros(x)) return ctranspose(x); // zero matrixx\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              try {\n                return inv(x); // invertible matrix\n              } catch (err) {\n                if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {\n                  // Expected\n                } else {\n                  throw err;\n                }\n              }\n            }\n            if (isMatrix(x)) {\n              return matrix(_pinv(x.valueOf(), rows, cols), x.storage());\n            } else {\n              // return an Array\n              return _pinv(x, rows, cols);\n            }\n          }\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    },\n    any: function any(x) {\n      // scalar\n      if (equal(x, 0)) return clone(x); // zero\n      return divideScalar(1, x);\n    }\n  });\n\n  /**\n   * Calculate the Moore–Penrose inverse of a matrix\n   * @param {Array[]} mat     A matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns\n   * @return {Array[]} pinv    Pseudoinverse matrix\n   * @private\n   */\n  function _pinv(mat, rows, cols) {\n    var _rankFact2 = _rankFact(mat, rows, cols),\n      C = _rankFact2.C,\n      F = _rankFact2.F; // TODO: Use SVD instead (may improve precision)\n    var Cpinv = multiply(inv(multiply(ctranspose(C), C)), ctranspose(C));\n    var Fpinv = multiply(ctranspose(F), inv(multiply(F, ctranspose(F))));\n    return multiply(Fpinv, Cpinv);\n  }\n\n  /**\n   * Calculate the reduced row echelon form of a matrix\n   *\n   * Modified from https://rosettacode.org/wiki/Reduced_row_echelon_form\n   *\n   * @param {Array[]} mat     A matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns\n   * @return {Array[]}        Reduced row echelon form\n   * @private\n   */\n  function _rref(mat, rows, cols) {\n    var M = clone(mat);\n    var lead = 0;\n    for (var r = 0; r < rows; r++) {\n      if (cols <= lead) {\n        return M;\n      }\n      var i = r;\n      while (_isZero(M[i][lead])) {\n        i++;\n        if (rows === i) {\n          i = r;\n          lead++;\n          if (cols === lead) {\n            return M;\n          }\n        }\n      }\n      var _ref2 = [M[r], M[i]];\n      M[i] = _ref2[0];\n      M[r] = _ref2[1];\n      var val = M[r][lead];\n      for (var j = 0; j < cols; j++) {\n        M[r][j] = dotDivide(M[r][j], val);\n      }\n      for (var _i = 0; _i < rows; _i++) {\n        if (_i === r) continue;\n        val = M[_i][lead];\n        for (var _j = 0; _j < cols; _j++) {\n          M[_i][_j] = add(M[_i][_j], multiply(-1, multiply(val, M[r][_j])));\n        }\n      }\n      lead++;\n    }\n    return M;\n  }\n\n  /**\n   * Calculate the rank factorization of a matrix\n   *\n   * @param {Array[]} mat                  A matrix (M)\n   * @param {number} rows                  Number of rows\n   * @param {number} cols                  Number of columns\n   * @return {{C: Array, F: Array}}        rank factorization where M = C F\n   * @private\n   */\n  function _rankFact(mat, rows, cols) {\n    var rref = _rref(mat, rows, cols);\n    var C = mat.map(function (_, i) {\n      return _.filter(function (_, j) {\n        return j < rows && !_isZero(dot(rref[j], rref[j]));\n      });\n    });\n    var F = rref.filter(function (_, i) {\n      return !_isZero(dot(rref[i], rref[i]));\n    });\n    return {\n      C: C,\n      F: F\n    };\n  }\n  function _isZero(x) {\n    return equal(add(x, Complex(1, 1)), add(0, Complex(1, 1)));\n  }\n  function _isZeros(arr) {\n    return deepEqual(add(arr, Complex(1, 1)), add(multiply(arr, 0), Complex(1, 1)));\n  }\n});","map":{"version":3,"names":["isMatrix","arraySize","factory","format","clone","name","dependencies","createPinv","_ref","typed","matrix","inv","deepEqual","equal","dotDivide","dot","ctranspose","divideScalar","multiply","add","Complex","ArrayMatrix","x","size","length","_isZeros","rows","cols","err","Error","message","match","_pinv","valueOf","storage","RangeError","any","mat","_rankFact2","_rankFact","C","F","Cpinv","Fpinv","_rref","M","lead","r","i","_isZero","_ref2","val","j","_i","_j","rref","map","_","filter","arr"],"sources":["C:/Users/chpha/Desktop/calculator/node_modules/mathjs/lib/esm/function/matrix/pinv.js"],"sourcesContent":["import { isMatrix } from '../../utils/is.js';\nimport { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { format } from '../../utils/string.js';\nimport { clone } from '../../utils/object.js';\nvar name = 'pinv';\nvar dependencies = ['typed', 'matrix', 'inv', 'deepEqual', 'equal', 'dotDivide', 'dot', 'ctranspose', 'divideScalar', 'multiply', 'add', 'Complex'];\nexport var createPinv = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    inv,\n    deepEqual,\n    equal,\n    dotDivide,\n    dot,\n    ctranspose,\n    divideScalar,\n    multiply,\n    add,\n    Complex\n  } = _ref;\n  /**\n   * Calculate the Moore–Penrose inverse of a matrix.\n   *\n   * Syntax:\n   *\n   *     math.pinv(x)\n   *\n   * Examples:\n   *\n   *     math.pinv([[1, 2], [3, 4]])          // returns [[-2, 1], [1.5, -0.5]]\n   *     math.pinv([[1, 0], [0, 1], [0, 1]])  // returns [[1, 0, 0], [0, 0.5, 0.5]]\n   *     math.pinv(4)                         // returns 0.25\n   *\n   * See also:\n   *\n   *     inv\n   *\n   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed\n   * @return {number | Complex | Array | Matrix} The inverse of `x`.\n   */\n  return typed(name, {\n    'Array | Matrix': function ArrayMatrix(x) {\n      var size = isMatrix(x) ? x.size() : arraySize(x);\n      switch (size.length) {\n        case 1:\n          // vector\n          if (_isZeros(x)) return ctranspose(x); // null vector\n          if (size[0] === 1) {\n            return inv(x); // invertible matrix\n          } else {\n            return dotDivide(ctranspose(x), dot(x, x));\n          }\n        case 2:\n          // two dimensional array\n          {\n            if (_isZeros(x)) return ctranspose(x); // zero matrixx\n            var rows = size[0];\n            var cols = size[1];\n            if (rows === cols) {\n              try {\n                return inv(x); // invertible matrix\n              } catch (err) {\n                if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {\n                  // Expected\n                } else {\n                  throw err;\n                }\n              }\n            }\n            if (isMatrix(x)) {\n              return matrix(_pinv(x.valueOf(), rows, cols), x.storage());\n            } else {\n              // return an Array\n              return _pinv(x, rows, cols);\n            }\n          }\n        default:\n          // multi dimensional array\n          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');\n      }\n    },\n    any: function any(x) {\n      // scalar\n      if (equal(x, 0)) return clone(x); // zero\n      return divideScalar(1, x);\n    }\n  });\n\n  /**\n   * Calculate the Moore–Penrose inverse of a matrix\n   * @param {Array[]} mat     A matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns\n   * @return {Array[]} pinv    Pseudoinverse matrix\n   * @private\n   */\n  function _pinv(mat, rows, cols) {\n    var {\n      C,\n      F\n    } = _rankFact(mat, rows, cols); // TODO: Use SVD instead (may improve precision)\n    var Cpinv = multiply(inv(multiply(ctranspose(C), C)), ctranspose(C));\n    var Fpinv = multiply(ctranspose(F), inv(multiply(F, ctranspose(F))));\n    return multiply(Fpinv, Cpinv);\n  }\n\n  /**\n   * Calculate the reduced row echelon form of a matrix\n   *\n   * Modified from https://rosettacode.org/wiki/Reduced_row_echelon_form\n   *\n   * @param {Array[]} mat     A matrix\n   * @param {number} rows     Number of rows\n   * @param {number} cols     Number of columns\n   * @return {Array[]}        Reduced row echelon form\n   * @private\n   */\n  function _rref(mat, rows, cols) {\n    var M = clone(mat);\n    var lead = 0;\n    for (var r = 0; r < rows; r++) {\n      if (cols <= lead) {\n        return M;\n      }\n      var i = r;\n      while (_isZero(M[i][lead])) {\n        i++;\n        if (rows === i) {\n          i = r;\n          lead++;\n          if (cols === lead) {\n            return M;\n          }\n        }\n      }\n      [M[i], M[r]] = [M[r], M[i]];\n      var val = M[r][lead];\n      for (var j = 0; j < cols; j++) {\n        M[r][j] = dotDivide(M[r][j], val);\n      }\n      for (var _i = 0; _i < rows; _i++) {\n        if (_i === r) continue;\n        val = M[_i][lead];\n        for (var _j = 0; _j < cols; _j++) {\n          M[_i][_j] = add(M[_i][_j], multiply(-1, multiply(val, M[r][_j])));\n        }\n      }\n      lead++;\n    }\n    return M;\n  }\n\n  /**\n   * Calculate the rank factorization of a matrix\n   *\n   * @param {Array[]} mat                  A matrix (M)\n   * @param {number} rows                  Number of rows\n   * @param {number} cols                  Number of columns\n   * @return {{C: Array, F: Array}}        rank factorization where M = C F\n   * @private\n   */\n  function _rankFact(mat, rows, cols) {\n    var rref = _rref(mat, rows, cols);\n    var C = mat.map((_, i) => _.filter((_, j) => j < rows && !_isZero(dot(rref[j], rref[j]))));\n    var F = rref.filter((_, i) => !_isZero(dot(rref[i], rref[i])));\n    return {\n      C,\n      F\n    };\n  }\n  function _isZero(x) {\n    return equal(add(x, Complex(1, 1)), add(0, Complex(1, 1)));\n  }\n  function _isZeros(arr) {\n    return deepEqual(add(arr, Complex(1, 1)), add(multiply(arr, 0), Complex(1, 1)));\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}