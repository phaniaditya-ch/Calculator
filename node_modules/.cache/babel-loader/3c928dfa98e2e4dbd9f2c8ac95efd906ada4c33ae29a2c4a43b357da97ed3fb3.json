{"ast":null,"code":"import _classCallCheck from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { format } from '../../utils/string.js';\nimport { typeOf } from '../../utils/is.js';\nimport { escapeLatex } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ConstantNode';\nvar dependencies = ['Node'];\nexport var createConstantNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  var ConstantNode = /*#__PURE__*/function (_Node) {\n    _inherits(ConstantNode, _Node);\n    var _super = _createSuper(ConstantNode);\n    /**\n     * A ConstantNode holds a constant value like a number or string.\n     *\n     * Usage:\n     *\n     *     new ConstantNode(2.3)\n     *     new ConstantNode('hello')\n     *\n     * @param {*} value    Value can be any type (number, BigNumber, string, ...)\n     * @constructor ConstantNode\n     * @extends {Node}\n     */\n    function ConstantNode(value) {\n      var _this;\n      _classCallCheck(this, ConstantNode);\n      _this = _super.call(this);\n      _this.value = value;\n      return _this;\n    }\n    _createClass(ConstantNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isConstantNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        var value = this.value;\n        return function evalConstantNode() {\n          return value;\n        };\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        // nothing to do, we don't have any children\n      }\n\n      /**\n       * Create a new ConstantNode with children produced by the given callback.\n       * Trivial because there are no children.\n       * @param {function(child: Node, path: string, parent: Node) : Node} callback\n       * @returns {ConstantNode} Returns a clone of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        return this.clone();\n      }\n\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {ConstantNode}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new ConstantNode(this.value);\n      }\n\n      /**\n       * Get string representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        return format(this.value, options);\n      }\n\n      /**\n       * Get HTML representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"toHTML\",\n      value: function toHTML(options) {\n        var value = this._toString(options);\n        switch (typeOf(this.value)) {\n          case 'number':\n          case 'BigNumber':\n          case 'Fraction':\n            return '<span class=\"math-number\">' + value + '</span>';\n          case 'string':\n            return '<span class=\"math-string\">' + value + '</span>';\n          case 'boolean':\n            return '<span class=\"math-boolean\">' + value + '</span>';\n          case 'null':\n            return '<span class=\"math-null-symbol\">' + value + '</span>';\n          case 'undefined':\n            return '<span class=\"math-undefined\">' + value + '</span>';\n          default:\n            return '<span class=\"math-symbol\">' + value + '</span>';\n        }\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: name,\n          value: this.value\n        };\n      }\n\n      /**\n       * Instantiate a ConstantNode from its JSON representation\n       * @param {Object} json  An object structured like\n       *                       `{\"mathjs\": \"SymbolNode\", value: 2.3}`,\n       *                       where mathjs is optional\n       * @returns {ConstantNode}\n       */\n    }, {\n      key: \"_toTex\",\n      value:\n      /**\n       * Get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       */\n      function _toTex(options) {\n        var value = this._toString(options);\n        switch (typeOf(this.value)) {\n          case 'string':\n            return '\\\\mathtt{' + escapeLatex(value) + '}';\n          case 'number':\n          case 'BigNumber':\n            {\n              if (!isFinite(this.value)) {\n                return this.value.valueOf() < 0 ? '-\\\\infty' : '\\\\infty';\n              }\n              var index = value.toLowerCase().indexOf('e');\n              if (index !== -1) {\n                return value.substring(0, index) + '\\\\cdot10^{' + value.substring(index + 1) + '}';\n              }\n            }\n            return value;\n          case 'Fraction':\n            return this.value.toLatex();\n          default:\n            return value;\n        }\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new ConstantNode(json.value);\n      }\n    }]);\n    return ConstantNode;\n  }(Node);\n  _defineProperty(ConstantNode, \"name\", name);\n  return ConstantNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","format","typeOf","escapeLatex","factory","name","dependencies","createConstantNode","_ref","Node","ConstantNode","_Node","_inherits","_super","_createSuper","value","_this","_classCallCheck","call","_createClass","key","get","_compile","math","argNames","evalConstantNode","forEach","callback","map","clone","_toString","options","toHTML","toJSON","mathjs","_toTex","isFinite","valueOf","index","toLowerCase","indexOf","substring","toLatex","fromJSON","json","isClass","isNode"],"sources":["C:/Users/chpha/Desktop/calculator/node_modules/mathjs/lib/esm/expression/node/ConstantNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { format } from '../../utils/string.js';\nimport { typeOf } from '../../utils/is.js';\nimport { escapeLatex } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ConstantNode';\nvar dependencies = ['Node'];\nexport var createConstantNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  class ConstantNode extends Node {\n    /**\n     * A ConstantNode holds a constant value like a number or string.\n     *\n     * Usage:\n     *\n     *     new ConstantNode(2.3)\n     *     new ConstantNode('hello')\n     *\n     * @param {*} value    Value can be any type (number, BigNumber, string, ...)\n     * @constructor ConstantNode\n     * @extends {Node}\n     */\n    constructor(value) {\n      super();\n      this.value = value;\n    }\n    get type() {\n      return name;\n    }\n    get isConstantNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var value = this.value;\n      return function evalConstantNode() {\n        return value;\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      // nothing to do, we don't have any children\n    }\n\n    /**\n     * Create a new ConstantNode with children produced by the given callback.\n     * Trivial because there are no children.\n     * @param {function(child: Node, path: string, parent: Node) : Node} callback\n     * @returns {ConstantNode} Returns a clone of the node\n     */\n    map(callback) {\n      return this.clone();\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {ConstantNode}\n     */\n    clone() {\n      return new ConstantNode(this.value);\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      return format(this.value, options);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      var value = this._toString(options);\n      switch (typeOf(this.value)) {\n        case 'number':\n        case 'BigNumber':\n        case 'Fraction':\n          return '<span class=\"math-number\">' + value + '</span>';\n        case 'string':\n          return '<span class=\"math-string\">' + value + '</span>';\n        case 'boolean':\n          return '<span class=\"math-boolean\">' + value + '</span>';\n        case 'null':\n          return '<span class=\"math-null-symbol\">' + value + '</span>';\n        case 'undefined':\n          return '<span class=\"math-undefined\">' + value + '</span>';\n        default:\n          return '<span class=\"math-symbol\">' + value + '</span>';\n      }\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        value: this.value\n      };\n    }\n\n    /**\n     * Instantiate a ConstantNode from its JSON representation\n     * @param {Object} json  An object structured like\n     *                       `{\"mathjs\": \"SymbolNode\", value: 2.3}`,\n     *                       where mathjs is optional\n     * @returns {ConstantNode}\n     */\n    static fromJSON(json) {\n      return new ConstantNode(json.value);\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var value = this._toString(options);\n      switch (typeOf(this.value)) {\n        case 'string':\n          return '\\\\mathtt{' + escapeLatex(value) + '}';\n        case 'number':\n        case 'BigNumber':\n          {\n            if (!isFinite(this.value)) {\n              return this.value.valueOf() < 0 ? '-\\\\infty' : '\\\\infty';\n            }\n            var index = value.toLowerCase().indexOf('e');\n            if (index !== -1) {\n              return value.substring(0, index) + '\\\\cdot10^{' + value.substring(index + 1) + '}';\n            }\n          }\n          return value;\n        case 'Fraction':\n          return this.value.toLatex();\n        default:\n          return value;\n      }\n    }\n  }\n  _defineProperty(ConstantNode, \"name\", name);\n  return ConstantNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":";;;;AAAA,OAAOA,eAAe,MAAM,uCAAuC;AACnE,SAASC,MAAM,QAAQ,uBAAuB;AAC9C,SAASC,MAAM,QAAQ,mBAAmB;AAC1C,SAASC,WAAW,QAAQ,sBAAsB;AAClD,SAASC,OAAO,QAAQ,wBAAwB;AAChD,IAAIC,IAAI,GAAG,cAAc;AACzB,IAAIC,YAAY,GAAG,CAAC,MAAM,CAAC;AAC3B,OAAO,IAAIC,kBAAkB,GAAG,eAAeH,OAAO,CAACC,IAAI,EAAEC,YAAY,EAAE,UAAAE,IAAI,EAAI;EACjF,IACEC,IAAI,GACFD,IAAI,CADNC,IAAI;EACG,IACHC,YAAY,0BAAAC,KAAA;IAAAC,SAAA,CAAAF,YAAA,EAAAC,KAAA;IAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,YAAA;IAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,SAAAA,aAAYK,KAAK,EAAE;MAAA,IAAAC,KAAA;MAAAC,eAAA,OAAAP,YAAA;MACjBM,KAAA,GAAAH,MAAA,CAAAK,IAAA;MACAF,KAAA,CAAKD,KAAK,GAAGA,KAAK;MAAC,OAAAC,KAAA;IACrB;IAACG,YAAA,CAAAT,YAAA;MAAAU,GAAA;MAAAC,GAAA,EACD,SAAAA,IAAA,EAAW;QACT,OAAOhB,IAAI;MACb;IAAC;MAAAe,GAAA;MAAAC,GAAA,EACD,SAAAA,IAAA,EAAqB;QACnB,OAAO,IAAI;MACb;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAZI;MAAAD,GAAA;MAAAL,KAAA,EAaA,SAAAO,SAASC,IAAI,EAAEC,QAAQ,EAAE;QACvB,IAAIT,KAAK,GAAG,IAAI,CAACA,KAAK;QACtB,OAAO,SAASU,gBAAgBA,CAAA,EAAG;UACjC,OAAOV,KAAK;QACd,CAAC;MACH;;MAEA;AACJ;AACA;AACA;IAHI;MAAAK,GAAA;MAAAL,KAAA,EAIA,SAAAW,QAAQC,QAAQ,EAAE;QAChB;MAAA;;MAGF;AACJ;AACA;AACA;AACA;AACA;IALI;MAAAP,GAAA;MAAAL,KAAA,EAMA,SAAAa,IAAID,QAAQ,EAAE;QACZ,OAAO,IAAI,CAACE,KAAK,EAAE;MACrB;;MAEA;AACJ;AACA;AACA;IAHI;MAAAT,GAAA;MAAAL,KAAA,EAIA,SAAAc,MAAA,EAAQ;QACN,OAAO,IAAInB,YAAY,CAAC,IAAI,CAACK,KAAK,CAAC;MACrC;;MAEA;AACJ;AACA;AACA;AACA;IAJI;MAAAK,GAAA;MAAAL,KAAA,EAKA,SAAAe,UAAUC,OAAO,EAAE;QACjB,OAAO9B,MAAM,CAAC,IAAI,CAACc,KAAK,EAAEgB,OAAO,CAAC;MACpC;;MAEA;AACJ;AACA;AACA;AACA;IAJI;MAAAX,GAAA;MAAAL,KAAA,EAKA,SAAAiB,OAAOD,OAAO,EAAE;QACd,IAAIhB,KAAK,GAAG,IAAI,CAACe,SAAS,CAACC,OAAO,CAAC;QACnC,QAAQ7B,MAAM,CAAC,IAAI,CAACa,KAAK,CAAC;UACxB,KAAK,QAAQ;UACb,KAAK,WAAW;UAChB,KAAK,UAAU;YACb,OAAO,4BAA4B,GAAGA,KAAK,GAAG,SAAS;UACzD,KAAK,QAAQ;YACX,OAAO,4BAA4B,GAAGA,KAAK,GAAG,SAAS;UACzD,KAAK,SAAS;YACZ,OAAO,6BAA6B,GAAGA,KAAK,GAAG,SAAS;UAC1D,KAAK,MAAM;YACT,OAAO,iCAAiC,GAAGA,KAAK,GAAG,SAAS;UAC9D,KAAK,WAAW;YACd,OAAO,+BAA+B,GAAGA,KAAK,GAAG,SAAS;UAC5D;YACE,OAAO,4BAA4B,GAAGA,KAAK,GAAG,SAAS;QAAC;MAE9D;;MAEA;AACJ;AACA;AACA;IAHI;MAAAK,GAAA;MAAAL,KAAA,EAIA,SAAAkB,OAAA,EAAS;QACP,OAAO;UACLC,MAAM,EAAE7B,IAAI;UACZU,KAAK,EAAE,IAAI,CAACA;QACd,CAAC;MACH;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IANI;MAAAK,GAAA;MAAAL,KAAA;MAWA;AACJ;AACA;AACA;AACA;MACI,SAAAoB,OAAOJ,OAAO,EAAE;QACd,IAAIhB,KAAK,GAAG,IAAI,CAACe,SAAS,CAACC,OAAO,CAAC;QACnC,QAAQ7B,MAAM,CAAC,IAAI,CAACa,KAAK,CAAC;UACxB,KAAK,QAAQ;YACX,OAAO,WAAW,GAAGZ,WAAW,CAACY,KAAK,CAAC,GAAG,GAAG;UAC/C,KAAK,QAAQ;UACb,KAAK,WAAW;YACd;cACE,IAAI,CAACqB,QAAQ,CAAC,IAAI,CAACrB,KAAK,CAAC,EAAE;gBACzB,OAAO,IAAI,CAACA,KAAK,CAACsB,OAAO,EAAE,GAAG,CAAC,GAAG,UAAU,GAAG,SAAS;cAC1D;cACA,IAAIC,KAAK,GAAGvB,KAAK,CAACwB,WAAW,EAAE,CAACC,OAAO,CAAC,GAAG,CAAC;cAC5C,IAAIF,KAAK,KAAK,CAAC,CAAC,EAAE;gBAChB,OAAOvB,KAAK,CAAC0B,SAAS,CAAC,CAAC,EAAEH,KAAK,CAAC,GAAG,YAAY,GAAGvB,KAAK,CAAC0B,SAAS,CAACH,KAAK,GAAG,CAAC,CAAC,GAAG,GAAG;cACpF;YACF;YACA,OAAOvB,KAAK;UACd,KAAK,UAAU;YACb,OAAO,IAAI,CAACA,KAAK,CAAC2B,OAAO,EAAE;UAC7B;YACE,OAAO3B,KAAK;QAAC;MAEnB;IAAC;MAAAK,GAAA;MAAAL,KAAA,EA/BD,SAAA4B,SAAgBC,IAAI,EAAE;QACpB,OAAO,IAAIlC,YAAY,CAACkC,IAAI,CAAC7B,KAAK,CAAC;MACrC;IAAC;IAAA,OAAAL,YAAA;EAAA,EA5HwBD,IAAI;EA2J/BT,eAAe,CAACU,YAAY,EAAE,MAAM,EAAEL,IAAI,CAAC;EAC3C,OAAOK,YAAY;AACrB,CAAC,EAAE;EACDmC,OAAO,EAAE,IAAI;EACbC,MAAM,EAAE;AACV,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}