{"ast":null,"code":"import _classCallCheck from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/chpha/Desktop/calculator/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @param {string} implicit\n   * @return {Object} parentheses\n   * @private\n   */\n  function calculateNecessaryParentheses(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  var RangeNode = /*#__PURE__*/function (_Node) {\n    _inherits(RangeNode, _Node);\n    var _super = _createSuper(RangeNode);\n    /**\n     * @constructor RangeNode\n     * @extends {Node}\n     * create a range\n     * @param {Node} start  included lower-bound\n     * @param {Node} end    included upper-bound\n     * @param {Node} [step] optional step\n     */\n    function RangeNode(start, end, step) {\n      var _this;\n      _classCallCheck(this, RangeNode);\n      _this = _super.call(this);\n      // validate inputs\n      if (!isNode(start)) throw new TypeError('Node expected');\n      if (!isNode(end)) throw new TypeError('Node expected');\n      if (step && !isNode(step)) throw new TypeError('Node expected');\n      if (arguments.length > 3) throw new Error('Too many arguments');\n      _this.start = start; // included lower-bound\n      _this.end = end; // included upper-bound\n      _this.step = step || null; // optional step\n      return _this;\n    }\n    _createClass(RangeNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isRangeNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Check whether the RangeNode needs the `end` symbol to be defined.\n       * This end is the size of the Matrix in current dimension.\n       * @return {boolean}\n       */\n    }, {\n      key: \"needsEnd\",\n      value: function needsEnd() {\n        // find all `end` symbols in this RangeNode\n        var endSymbols = this.filter(function (node) {\n          return isSymbolNode(node) && node.name === 'end';\n        });\n        return endSymbols.length > 0;\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        var range = math.range;\n        var evalStart = this.start._compile(math, argNames);\n        var evalEnd = this.end._compile(math, argNames);\n        if (this.step) {\n          var evalStep = this.step._compile(math, argNames);\n          return function evalRangeNode(scope, args, context) {\n            return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n          };\n        } else {\n          return function evalRangeNode(scope, args, context) {\n            return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n          };\n        }\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        callback(this.start, 'start', this);\n        callback(this.end, 'end', this);\n        if (this.step) {\n          callback(this.step, 'step', this);\n        }\n      }\n\n      /**\n       * Create a new RangeNode whose children are the results of calling\n       * the provided callback function for each child of the original node.\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\n       * @returns {RangeNode} Returns a transformed copy of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n      }\n\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {RangeNode}\n       */\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new RangeNode(this.start, this.end, this.step && this.step);\n      }\n\n      /**\n       * Get string representation\n       * @param {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n\n        // format string as start:step:stop\n        var str;\n        var start = this.start.toString(options);\n        if (parens.start) {\n          start = '(' + start + ')';\n        }\n        str = start;\n        if (this.step) {\n          var step = this.step.toString(options);\n          if (parens.step) {\n            step = '(' + step + ')';\n          }\n          str += ':' + step;\n        }\n        var end = this.end.toString(options);\n        if (parens.end) {\n          end = '(' + end + ')';\n        }\n        str += ':' + end;\n        return str;\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: name,\n          start: this.start,\n          end: this.end,\n          step: this.step\n        };\n      }\n\n      /**\n       * Instantiate an RangeNode from its JSON representation\n       * @param {Object} json\n       *     An object structured like\n       *     `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n       *     where mathjs is optional\n       * @returns {RangeNode}\n       */\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\n       * Get HTML representation\n       * @param {Object} options\n       * @return {string} str\n       */\n      function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n\n        // format string as start:step:stop\n        var str;\n        var start = this.start.toHTML(options);\n        if (parens.start) {\n          start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        str = start;\n        if (this.step) {\n          var step = this.step.toHTML(options);\n          if (parens.step) {\n            step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n          str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n        }\n        var end = this.end.toHTML(options);\n        if (parens.end) {\n          end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n        return str;\n      }\n\n      /**\n       * Get LaTeX representation\n       * @params {Object} options\n       * @return {string} str\n       */\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n        var str = this.start.toTex(options);\n        if (parens.start) {\n          str = \"\\\\left(\".concat(str, \"\\\\right)\");\n        }\n        if (this.step) {\n          var step = this.step.toTex(options);\n          if (parens.step) {\n            step = \"\\\\left(\".concat(step, \"\\\\right)\");\n          }\n          str += ':' + step;\n        }\n        var end = this.end.toTex(options);\n        if (parens.end) {\n          end = \"\\\\left(\".concat(end, \"\\\\right)\");\n        }\n        str += ':' + end;\n        return str;\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new RangeNode(json.start, json.end, json.step);\n      }\n    }]);\n    return RangeNode;\n  }(Node);\n  _defineProperty(RangeNode, \"name\", name);\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isNode","isSymbolNode","factory","getPrecedence","name","dependencies","createRangeNode","_ref","Node","calculateNecessaryParentheses","node","parenthesis","implicit","precedence","parens","startPrecedence","start","step","stepPrecedence","endPrecedence","end","RangeNode","_Node","_inherits","_super","_createSuper","_this","_classCallCheck","call","TypeError","arguments","length","Error","_createClass","key","get","value","needsEnd","endSymbols","filter","_compile","math","argNames","range","evalStart","evalEnd","evalStep","evalRangeNode","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","str","toString","toJSON","mathjs","toHTML","_toTex","toTex","concat","fromJSON","json","isClass"],"sources":["C:/Users/chpha/Desktop/calculator/node_modules/mathjs/lib/esm/expression/node/RangeNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @param {string} implicit\n   * @return {Object} parentheses\n   * @private\n   */\n  function calculateNecessaryParentheses(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n  class RangeNode extends Node {\n    /**\n     * @constructor RangeNode\n     * @extends {Node}\n     * create a range\n     * @param {Node} start  included lower-bound\n     * @param {Node} end    included upper-bound\n     * @param {Node} [step] optional step\n     */\n    constructor(start, end, step) {\n      super();\n      // validate inputs\n      if (!isNode(start)) throw new TypeError('Node expected');\n      if (!isNode(end)) throw new TypeError('Node expected');\n      if (step && !isNode(step)) throw new TypeError('Node expected');\n      if (arguments.length > 3) throw new Error('Too many arguments');\n      this.start = start; // included lower-bound\n      this.end = end; // included upper-bound\n      this.step = step || null; // optional step\n    }\n\n    get type() {\n      return name;\n    }\n    get isRangeNode() {\n      return true;\n    }\n\n    /**\n     * Check whether the RangeNode needs the `end` symbol to be defined.\n     * This end is the size of the Matrix in current dimension.\n     * @return {boolean}\n     */\n    needsEnd() {\n      // find all `end` symbols in this RangeNode\n      var endSymbols = this.filter(function (node) {\n        return isSymbolNode(node) && node.name === 'end';\n      });\n      return endSymbols.length > 0;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var range = math.range;\n      var evalStart = this.start._compile(math, argNames);\n      var evalEnd = this.end._compile(math, argNames);\n      if (this.step) {\n        var evalStep = this.step._compile(math, argNames);\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n        };\n      } else {\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n        };\n      }\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      callback(this.start, 'start', this);\n      callback(this.end, 'end', this);\n      if (this.step) {\n        callback(this.step, 'step', this);\n      }\n    }\n\n    /**\n     * Create a new RangeNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {RangeNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {RangeNode}\n     */\n    clone() {\n      return new RangeNode(this.start, this.end, this.step && this.step);\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n\n      // format string as start:step:stop\n      var str;\n      var start = this.start.toString(options);\n      if (parens.start) {\n        start = '(' + start + ')';\n      }\n      str = start;\n      if (this.step) {\n        var step = this.step.toString(options);\n        if (parens.step) {\n          step = '(' + step + ')';\n        }\n        str += ':' + step;\n      }\n      var end = this.end.toString(options);\n      if (parens.end) {\n        end = '(' + end + ')';\n      }\n      str += ':' + end;\n      return str;\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        start: this.start,\n        end: this.end,\n        step: this.step\n      };\n    }\n\n    /**\n     * Instantiate an RangeNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n     *     where mathjs is optional\n     * @returns {RangeNode}\n     */\n    static fromJSON(json) {\n      return new RangeNode(json.start, json.end, json.step);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n\n      // format string as start:step:stop\n      var str;\n      var start = this.start.toHTML(options);\n      if (parens.start) {\n        start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      str = start;\n      if (this.step) {\n        var step = this.step.toHTML(options);\n        if (parens.step) {\n          step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n      }\n      var end = this.end.toHTML(options);\n      if (parens.end) {\n        end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n      return str;\n    }\n\n    /**\n     * Get LaTeX representation\n     * @params {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n      var str = this.start.toTex(options);\n      if (parens.start) {\n        str = \"\\\\left(\".concat(str, \"\\\\right)\");\n      }\n      if (this.step) {\n        var step = this.step.toTex(options);\n        if (parens.step) {\n          step = \"\\\\left(\".concat(step, \"\\\\right)\");\n        }\n        str += ':' + step;\n      }\n      var end = this.end.toTex(options);\n      if (parens.end) {\n        end = \"\\\\left(\".concat(end, \"\\\\right)\");\n      }\n      str += ':' + end;\n      return str;\n    }\n  }\n  _defineProperty(RangeNode, \"name\", name);\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}